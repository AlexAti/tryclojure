<p>
  Now that we've covered the basics of prefix math, let's take some time to play with sequences.
</p>

<p>
  In Clojure, the term 'sequence' is an abstraction that many data structures implement. This
  abstraction allows any function that works on a 'seq' (pronounced seek) to work on any data
  structure that is seqable. This means all Clojure and Java collections, strings, and even
  I/O streams.
</p>

<p>
  In isolation this doesn't make sense, so let's play with vectors. A literal vector looks like
  this: <code>[1 2 3 "four" 5 6.0]</code>. Vectors are the most commonly used collection in 
  Clojure, along with maps. Let's see if we can square all of the elements of a vector:
  <code>(map (fn [x] (* x x)) [1 2 3 4 5])</code>. Try that out. The <code>map</code> function
  takes a function that takes a single argument and returns a value, which it 'applies' to each
  element of its second argument, a sequence. The resulting sequence is then returned.
</p>

<p>
  We have introduced something new here -- the anonymous function. Anonymous functions are used
  quite heavily in Clojure code. They are created using <code>fn</code>. After fn, you supply
  a vector of arguments that the function takes, and then the body of the function that uses those
  arguments to compute a value. Clojure has short hand for anonymous functions as well. The above
  anonymous function can be rewritten using a shorthand form: <code>#(* % %)</code>. When you
  use this shorthand, the function arguments are accessed like so: % or %1 for the first 
  argument, %2 for the second argument, %3 for the third and so on. Our code looks like this:
  <code>(map #(* % %) [1 2 3 4 5])</code>
</p>

<p>
  Another highly important collection is the hashmap. A literal hashmap looks like this:
  <code>{:key "value" :key2 3 :key4 [3 4 2 1]}</code>. The keys in this map are something 
  called 'keywords'. You can tell that they are keywords because they start with a colon ':' character.
  They're like symbols that resolve to themselves. In idiomatic Clojure code, keywords are often
  used as map keys. You can use many objects as map keys, including integers, vectors, strings,
  and other maps.
</p>

<p>
  To get a value at a key in a map, we can do this: <code>({:key1 :val1} :key1)</code>. I bet
  you're all lolwut right now, aren't you? In Clojure, hashmaps are functions that take a single
  argument, which should be a key and they lookup the key within themselves and return the value
  at the key or nil if the key doesn't exist. Another neat trick for maps with keywords for keys
  is this: <code>(:key1 {:key1 :val1})</code>. Keywords are also functions. They just look
  themselves up in the supplied map.
</p>

<p>
  Clojure has all sorts of other data structures as well. Sets, lists, queues, zippers, etc. 
  We'll talk about some of those later on. For now, let's move on to step four. Type next to 
  continue.
</p>
